<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Color Categorization</title>
		<style>
			* {
				font-family: monospace;
			}

			body {
				color: white;
			}

			.panel {
				width: 50vw;
				height: 100vh;
				position: fixed;

				top: 0;
			}

			#panel-left {
				left: 0;
			}

			#panel-right {
				background-color: #222;

				right: 0;
			}

			#data-display {
				width: 100%;
				height: 50%;
			}

			.color-choice {
				width: 9vh;
				height: 9vh;

				border: 2px solid rgba(255, 255, 255, .2);

				margin: 0;
			}

			.color-choice:active {
				border: 2px solid rgba(0, 0, 0, .2);
			}
		</style>
	</head>
	<body>
		<div class="panel" id="panel-left">
			<div id="choices">
			</div>
			<button onclick="undo()">UNDO</button>
		</div>
		<div class="panel" id="panel-right">
			<canvas id="data-display" width="360" height="100"></canvas>
			Colors categorized: <span id="colors-done"></span><br>
			Render: <div id="data-controls"></div><br>
			Data: <button onclick="exportDataButton()">Export</button><button onclick="importDataButton()">Import</button><textarea id="data"></textarea>
			<hr>
			Click the button on the left that you think most closely matches the color shown.
			You may press the "UNDO" button to take back your last color.
			<br><br>
			The "Outline" render button shows an overlay of your choices over the hue-luminance scale.
			The borders may look distorted, but that's because the points are actually on the surface of a sphere and are being projected onto a rectangle, just like a world map.
			<br><br>
			If you'd like to share your data with me, click the "export" button and use <a href="https://forms.gle/yhC1MrqeVh1pCkCUA">this form</a>.
			I'd really appreciate it!
		</div>
		<script src="./octTree.js"></script>
		<script>

			let sphericalColorSpace;
			let pointToColorChoiceIndex;

			function initialize() {
				sphericalColorSpace = new Cube(new Vec3(-1, -1, -1), 2, 32, false);
				pointToColorChoiceIndex = new Map();
			}
			initialize();

			const π = Math.PI;

			class Vec2 {
				x = 0;
				y = 0;
				constructor(x, y) {
					this.x = x;
					this.y = y;
				}
			}

			

			const colorChoices = [
				'red',
				'orange',
				'yellow',
				'green',
				'blue',
				'purple',
				'pink',
				'SaddleBrown',
				'white',
				'black'
			];

			let currentColor = null;

			function hueLuminanceToSurfaceOfSphere(vec2) {
				const θa = vec2.x * π / 180;
				const θb = vec2.y * π / 100;
				
				return new Vec3(
					Math.cos(θa) * Math.sin(θb),
					Math.sin(θa) * Math.sin(θb),
					Math.cos(θb)
				);
			}

			function updateColor() {
				document.getElementById('panel-left').style.backgroundColor = `hsl(${currentColor.x}deg, 100%, ${currentColor.y}%)`
			}

			function generateNewColor() {
				currentColor = new Vec2(
					Math.random() * 360,
					Math.acos(Math.random() * 2 - 1) / π * 100
				);

				updateColor();
			}

			function choose(colorString) {
				pointToColorChoiceIndex.set(currentColor, colorChoices.indexOf(colorString));
				sphericalColorSpace.add(new DataPoint(hueLuminanceToSurfaceOfSphere(currentColor), colorChoices.indexOf(colorString)))
				document.getElementById('colors-done').innerHTML = pointToColorChoiceIndex.size;
				generateNewColor();
			}

			document.addEventListener("click", function(e){
		  		const target = e.target.closest(".color-choice");
		  		
		  		if (target) {
		  			choose(target.id);
				}
			    
			});
		
			// Add color buttons
			for (color of colorChoices) {
				let button = document.createElement('button');

				//button.style.backgroundColor = color;
				button.classList.add('color-choice');
				button.id = color;
				const text = (c=>c == 'SaddleBrown' ? 'brown' : c)(color);
				button.innerHTML = text.substr(0, 1).toUpperCase() + text.substr(1);

				document.getElementById('choices').appendChild(button);
				document.getElementById('choices').appendChild(document.createElement('br'));
			}

			generateNewColor();







			// Data controls
			let dataMode = 0;
			let i = 0;
			let buttonDataArray = [
				[
					'Hue-Luminance',
					(x, y) => {
						return `hsl(${x}deg, 100%, ${y}%)`
					}
				],

				[
					'Your Choices',
					(x, y) => {

						const myPos = hueLuminanceToSurfaceOfSphere(new Vec2(x, y));

						
						/*
						let minDist = Infinity;
						let minPos = null;

						pointToColorChoiceIndex.keys().forEach(cartesianPos => {
							const otherPos = hueLuminanceToSurfaceOfSphere(cartesianPos);
							const lazyDist = (myPos.x - otherPos.x)**2 + (myPos.y - otherPos.y)**2 + (myPos.z - otherPos.z)**2;
							if (lazyDist < minDist) {
								minDist = lazyDist;
								minPos = cartesianPos
							}
						});

						return colorChoices[pointToColorChoiceIndex.get(minPos)];
						*/

						const dataPoint = sphericalColorSpace.findClosestDataPoint(myPos);

						return colorChoices[dataPoint.data];

					}
				],

				[
					'Outline',
					(x, y) => {
						const neighbors = [
							buttonDataArray[1][1](x + 1, y),
							buttonDataArray[1][1](x - 1, y),
							buttonDataArray[1][1](x, y + 1),
							buttonDataArray[1][1](x, y - 1)
						];
						const meColor = buttonDataArray[1][1](x, y);
						let border = false;
						neighbors.forEach(n => {
							if (n != meColor) {
								border = true;
							}
						});

						return border ? meColor : buttonDataArray[0][1](x, y);
					}
				]
			];

			buttonDataArray.forEach(buttonData => {
				document.getElementById('data-controls').innerHTML +=
				`<button onclick="dataMode=${i};redrawData()">${buttonData[0]}</button>`;
				i++;
			});

			function redrawData() {
				const canvas = document.getElementById('data-display');
				canvas.width = canvas.getBoundingClientRect().width;
				canvas.height = canvas.getBoundingClientRect().height;
				const ctx = canvas.getContext('2d');
				const func = buttonDataArray[dataMode][1];

				const startTime = new Date().getTime();
				for (let y = 0; y < canvas.height; y++) {
					for (let x = 0; x < canvas.width; x++) {
						ctx.fillStyle = func(x / (canvas.width / 360), y / (canvas.height / 100));
						ctx.fillRect(x, y, 1, 1);
					}	
				}
			}
			redrawData();


			function exportData() {
				let data = '';
				pointToColorChoiceIndex.keys().forEach(point => {
					data += `${Math.floor(point.x * 1000) / 1000},${Math.floor(point.y * 1000) / 1000},${pointToColorChoiceIndex.get(point)};`;
				});
				return data;
			}

			function importData(data) {
				initialize();

				data.split(';').forEach(dataPoint => {
					if (!dataPoint) return;
					dataPoint = dataPoint.split(',');
					currentColor = new Vec2(parseFloat(dataPoint[0]), parseFloat(dataPoint[1]));
					choose(colorChoices[parseInt(dataPoint[2])]);
				});
			}

			function exportDataButton() {
				document.getElementById('data').value = exportData();
			}

			function importDataButton() {
				importData(document.getElementById('data').value);
			}


			function undo() {
				const data = exportData().split(';');
				if (data.length < 2) return;
				data.pop();
				let dataPointToUndo = data.pop().split(',');
				importData(data.join(';'));
				currentColor = new Vec2(parseFloat(dataPointToUndo[0]), parseFloat(dataPointToUndo[1]));
				updateColor();
			}

		</script>
	</body>
</html>